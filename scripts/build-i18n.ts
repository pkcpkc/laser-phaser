import fs from 'fs';
import path from 'path';
import { glob } from 'glob';

const BASE_I18N_DIR = path.resolve('res/i18n');
const OUTPUT_BASE_DIR = path.resolve('src/generated');

console.log('Building i18n texts...');

// Find all subdirectories in res/i18n/
const folders = fs.readdirSync(BASE_I18N_DIR).filter(f => fs.statSync(path.join(BASE_I18N_DIR, f)).isDirectory());

folders.forEach(folder => {
    const SRC_DIR = path.join(BASE_I18N_DIR, folder);
    console.log(`Processing folder: ${folder}`);

    // e.g. folder "merchant" -> we look for "merchant*.md"
    const files = glob.sync(path.join(SRC_DIR, `${folder}*.md`));

    if (files.length === 0) {
        console.warn(`  No markdown files found in ${SRC_DIR}`);
        return;
    }

    const allData: Record<string, Record<string, Record<string, string>>> = {};

    files.forEach(file => {
        const filename = path.basename(file);

        // Match e.g. "storylines_de.md" or "merchant_fr.md"
        const regex = new RegExp(`^${folder}_([a-z]{2})\\.md$`);
        let locale = filename.match(regex)?.[1];

        if (!locale && filename === `${folder}.md`) {
            locale = 'en';
        }

        if (!locale) {
            console.warn(`  Skipping ${filename}: Could not determine locale`);
            return;
        }

        console.log(`  Parsing ${filename} (${locale})...`);
        const content = fs.readFileSync(file, 'utf-8');
        const data = parseMarkdown(content);

        allData[locale] = data;
    });

    // Generate TypeScript Content
    const tsContent = `/**
 * Auto-generated by scripts/build-i18n.ts
 * Do not edit manually.
 */

export const DATA: Record<string, Record<string, Record<string, string>>> = ${JSON.stringify(allData, null, 4)};

export function getText(groupId: string, itemId: string, locale: string = 'en'): string | null {
    const groupData = DATA[locale]?.[groupId] || DATA['en']?.[groupId];
    if (!groupData) return null;
    return groupData[itemId] || null;
}
`;

    // Ensure output directory
    const TS_OUT_FILE = path.join(OUTPUT_BASE_DIR, folder, `${folder}.ts`);
    const TS_OUT_DIR = path.dirname(TS_OUT_FILE);

    if (!fs.existsSync(TS_OUT_DIR)) {
        fs.mkdirSync(TS_OUT_DIR, { recursive: true });
    }

    fs.writeFileSync(TS_OUT_FILE, tsContent, 'utf-8');
    console.log(`  Saved compiled ${folder} to ${TS_OUT_FILE}`);
});

/**
 * Parses markdown content into a nested map structure:
 * {
 *   "group-id": {
 *     "item-id": "Text content..."
 *   }
 * }
 */
function parseMarkdown(markdown: string): Record<string, Record<string, string>> {
    const lines = markdown.split('\n');
    const result: Record<string, Record<string, string>> = {};

    let currentGroupId: string | null = null;
    let currentItemId: string | null = null;
    let currentTextLines: string[] = [];

    const saveCurrentText = () => {
        if (currentGroupId && currentItemId && currentTextLines.length > 0) {
            if (!result[currentGroupId]) {
                result[currentGroupId] = {};
            }
            // Join lines and trim extra whitespace
            const text = currentTextLines.join('\n').trim();
            if (text) {
                result[currentGroupId][currentItemId] = text;
            }
        }
        currentTextLines = [];
    };

    for (const line of lines) {
        const trimmed = line.trim();

        // Check for Group Header (e.g., "## group-id")
        if (trimmed.startsWith('## ')) {
            saveCurrentText();
            currentGroupId = trimmed.substring(3).trim();
            currentItemId = null;
        }
        // Check for Item Header (e.g., "### item-id")
        else if (trimmed.startsWith('### ')) {
            saveCurrentText();
            currentItemId = trimmed.substring(4).trim();
        }
        // Content lines
        else if (currentGroupId && currentItemId) {
            // Include empty lines if we have started collecting text, to preserve paragraph breaks
            // But skip leading empty lines of a block
            if (currentTextLines.length > 0 || trimmed !== '') {
                currentTextLines.push(line);
            }
        }
    }
    // Save last block
    saveCurrentText();

    return result;
}
